---
title: c++零散学习笔记
date: 2022-04-16 10:38:01
tags:
---
> 基础

1.指针常量：int * const p =& a;     p=&b是错误的，不可以更改地址；*p =20是可以更改的
   常量指针：const int * p =&a;     *p=20是错误的不可以更改；         p =&b;yes  
2.结构体指针来访问结构体中的属性 操作符  ->
3.值传递和地址传递（指针传递减少内存空间，不会像值传递额外复制一份）
4.int * p = new int(10); 返回的是一个个地址，用指针接收   指针 本质是局部变量，放在栈上，这个指针的值是放在堆上
5.int a = 10; int &b=a; * 引用必须要初始化 * 引用一旦初始化，就不可以更改
6.test() = 1000 ; 函数的返回值是引用，函数的调用可以作为左值
7.函数重载：1.同一个作用域下2.函数名称相同3.函数参数类型不同、个数不同、顺序不同4.函数的返回值是不可以作为函数重载的条件
> 封装继承

8.类中的属性和行为 我们统一称为成员
9.struct默认权限是公有，class 默认权限是私有
10.对象的初始化和清理---构造函数 析构函数
11.构造函数：1.没有返回值2.与类名相同3.有参数可以重载4.创建对象的时候会自动调用，而且只调用一次
12.析构函数：1.没有返回值2.函数名与类名相同，前面要加~ 3.析构函数不可以有参数 不能发生重载4. 对象在销毁前会自动调用一次
13.拷贝构造函数Person (const Person &p){}将传入的所有属性拷贝到当前身上
14.浅拷贝：堆区的内存重复释放 深拷贝可以解决这个问题
15.初始化列表：Person(int a,int b ,int c): m_A (a),m_B(b),m_C(c){}
16.其他类对象作为本类成员，构造时先构造类对象，再构造自身。析构的顺序与构造的顺序相反
17.运算符重载跳过，可以找别的视频看看
18.继承 class son :public father{   };继承方式不是只有public
19.继承中的构造和析构顺序：先构造父类，再构造子类，析构顺序与构造顺序相反。
20.{通过子类对象访问到父类同名成员，需要加个作用域----s.Base::m_A}成员函数也是加作用域
21.虚继承解决菱形继承，一般c++不怎么用多继承（***原理记得补一下***）
> 多态

22.地址早绑定 在编译阶段确定函数地址；动态多态 地址晚绑定，运行 阶段绑定地址 virtual可以解决
23.动态多态满足条件 1.有继承关系2.子类要重写父类的虚函数
24.函数返回值类型 函数名 参数列表 完全相同才是重写
25.动态多态的使用 父类的指针或引用 指向子类对象（***动态原理记得补一下**）
26.多态好处 1.组织结构清晰2.可读性强3.对于前期后期扩展以及维护性高-----开闭原则：对扩展进行开放，对修改进行封闭
27.当类中有了纯虚函数，这个类也称为抽象类，子类必须重写抽象类中的纯虚函数，抽象类无法实例化对象
28.利用虚析构可以解决父类指针释放子类对象不干净的问题，纯虚析构既要声明也要实现，有了纯虚析构之后，这个类也属于抽象类，无法实例化对象
> 文件操作

29.写文件1.包含头文件#include<fstream>2.创建流对象 ofstream ofs; 3.打开文件ofs.open("file path",打开方式)；4.写数据 ofs << "写入的数据";5.关闭文件ofs.close();
30.文件打开写 ios::out 文件打开读 ios::in
31.二进制读写记得看+职工管理系统
> 模板

32.函数模板 template<class T>：1.自动类型推导，必须推导出一致的数据类型T才可以使用2.模板必须要确定出T的数据类型才可以使用
33.如果函数模板和普通函数都可以调用，优先调用普通函数，通过空模板add<>(a,b);参数列表，可以强制调用模板
34.类模板在template <class T,class B>后面写类,类中例如 T name; B age;
35.类模板例子：Person<string ,int> p("张三",10)；给模板类型传值，给有参构造传值，
36.类模板没有自动类型推导的使用方式，上面的 Person p ("张三",10)是不行的，类模板在模板参数列表中有默认参数
37.类模板继承必须要知道父类的类型，才能进行继承
38.如果想灵活指定父类中T的类型，子类也需要变类模板
39.类模板成员函数类外实现1.要添加作用域2.函数上面添加tempalte<class...>3.作用域也要声明是类模板，在后面加入模板的参数列表
40.类模板分文件编写问题：类模板中成员函数创建时机是在调用阶段，分文件编写的时候调用不到 以及解决：声明和实现写在一起并用.hpp结尾
41.全局函数作为友元类内实现
42.全局函数类外实现--（没懂）模板案例

> STL

43.STL分为六大组件 容器、算法、迭代器、仿函数、适配器、空间配置器
44.vector<vector<int>>v;创建小容器
45.string容器，C++中string是一个类
46.string字符串赋值、拼接、查找和替换、字符串比较、字符存取、插入删除、子串。---一般下表从0开始
47.deque双向可以push pop
48.deque内部有中控器，维护每段缓冲区的内容，缓冲区存放真实数据，中控器维护的是缓冲区的地址
49.deque容器构造函数，赋值，插入和删除，数据存取，排序
50.stack先进后出 queue先进先出






